section .text
    global _start

section .data
    info_1 db 'Podaj liczbe: ', 0
    len_info_1 equ $-info_1
    
    info_2 db 'Podaj liczbe: ', 0
    len_info_2 equ $-info_2
    
    info_3 db 'Podaj znak +,-,*,/: ', 0
    len_info_3 equ $-info_3
    
    info_5 db 'Podaj znak (a - powtorzyc, c - wyczyscic wynik, e - wyjsc) c,e: ', 0
    len_info_5 equ $-info_5
    
    info_4 db 'Wynik: ', 0
    len_info_4 equ $-info_4
    
    info_6 db 'Exit', 0
    len_info_6 equ $-info_6
    
    Repeat_oper db 'Repeat_oper', 0
    len_Repeat_oper equ $-Repeat_oper
    
    Clear db 'Clear', 0
    len_Clear equ $-Clear

    endl db 10
    star db '*'
    no_v db '-'

section .bss
    operation_char resb 1
    operation_char_2 resb 1
    
    one_str resb 32
    one_int resb 32
    
    two_str resb 32
    two_int resb 32
    
    result_int resb 32
    result_str resb 32
    
    count resb 20
    count_two resb 20
    minus resb 1

section .text
_start:
    mov     dword [count], 0
    mov     dword [count_two], 0
    
beginning:
    mov     dword [count], 1
    
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, endl
    mov     edx, 1
    int     0x80
    
    
;   <FIRST NUMBER>
    mov     ecx, 32           
    mov     edi, one_str     
    xor     eax, eax          
    rep     stosb             
    
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, info_1
    mov     edx, len_info_1-1
    int     0x80
    
    cmp     dword [count], 1
    jg      repet_one
    
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, one_str
    mov     edx, 10
    int     0x80
    
    jmp     replace

repet_one:
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, one_str
    mov     edx, 10
    int     0x80
    
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, one_str
    mov     edx, 10
    int     0x80
    
    jmp     replace

replace:
    mov     ebx, one_str
    mov     ecx, one_int
    call    str_to_int

    mov     ebx, [one_int]
    mov     [result_int], ebx 
    
repeat_operation:
;   <SECOND NUMBER> 
    mov     ecx, 32           
    mov     edi, two_str      
    xor     eax, eax           
    rep     stosb              

    mov     eax, 4
    mov     ebx, 1
    mov     ecx, info_2
    mov     edx, len_info_2-1
    int     0x80

    cmp     dword [count], 2
    jg      repet_two
    
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, two_str
    mov     edx, 10
    int     0x80
    
    jmp     initialise

repet_two:
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, two_str
    mov     edx, 10
    int     0x80
    
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, two_str
    mov     edx, 10
    int     0x80
    
    jmp     initialise

initialise:
    mov     ebx, two_str
    mov     ecx, two_int
    call    str_to_int

;   <OPERATION>
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, info_3
    mov     edx, len_info_3-1
    int     0x80
    
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, operation_char
    mov     edx, 1
    int     0x80
    
    mov     edx, dword [result_int]
    mov     ebx, dword [two_int]
    
    
;   <CHOOSING>
    cmp     byte [operation_char], '+'
    je      addition
    
    cmp     byte [operation_char], '-'
    je      substraction
    
    cmp     byte [operation_char], '*'
    je      multiplication
    
    cmp     byte [operation_char], '/'
    je      division
    
    
;   <PRINT RESULT>
print_result:
    call    int_to_str

    mov     eax, 4
    mov     ebx, 1
    mov     ecx, info_4
    mov     edx, len_info_4-1
    int     0x80

    ; Prepare parameters for the write syscall
    mov     eax, 4          
    mov     ebx, 1           
    mov     ecx, [result_str] 
    mov     edx, 10        
    int     0x80            
    
    mov     dword [count], 2
 
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, endl
    mov     edx, 1
    int     0x80 
    
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, endl
    mov     edx, 1
    int     0x80 
    
    jmp     operation
    
    
;   <ADDITION one - edx, two - ebx>
addition:
    add     edx, ebx
    mov     [result_int], edx
    jmp     print_result


;   <SUBSTRACTION one - edx, two - ebx>
substraction:
    sub     edx, ebx
    mov     [result_int], edx
    jmp     print_result
    
    
;   <MULTIPLICATION WITH BITSHIFTS one - edx, two - ebx>
multiplication:
    mov     ecx, 32           
    xor     eax, eax           
    
multiply_loop:
    test    ebx, 1
    jnz     adding

shift:  
    shr     ebx, 1
    shl     edx, 1

    dec     ecx
    cmp     ecx, 0
    jne     multiply_loop
    jmp     print_result

adding:
    add     [result_int], edx  


;   <DIVISION WITH BITSHIFTS one - edx, two - ebx>
division:
    xor     ecx, ecx
    mov     eax, 1

counting_dividend:
    cmp     edx, 0
    je      counting_divisor
    
    shr     edx, 1
    inc     ecx
    
    jmp     counting_dividend
    
counting_divisor:
    mov     ebx, [two_int]
    
    imul    ebx, eax
    cmp     ebx, dword [one_int]
    jge     done
    
    inc     eax
    jmp     counting_divisor

done:
    cmp     ebx, dword [one_int]
    jg      dec_a
    jmp     return
    
dec_a:
    dec     eax
    jmp     return
    
return:
    mov     [result_int], eax
    jmp     print_result
    
;   <STRING TO DECIMAL INTEGER>
str_to_int:
    mov     eax, 0
    mov     edx, 0
    mov     byte [minus], 0

convert_loop:
    movzx   esi, byte [ebx + edx]
    test    esi, esi
    jz      convert_done

    cmp     esi, '-'
    je      add_minus  

check_number:    
    cmp     esi, '0'
    jl      skip_char
    cmp     esi, '9'
    jg      skip_char

add_number:
    sub     esi, '0'
    imul    eax, 10
    add     eax, esi
    
skip_char:
    inc     edx
    jmp     convert_loop
    
add_minus:
    mov     byte [minus], 1
    jmp check_number
    
convert_done:
    cmp     byte [minus], 1
    jge     get_negative
    jmp     end
    
get_negative:
    neg     eax
    
end:
    mov     dword [ecx], eax
    ret
    
;   <DECIMAL INTEGER TO STRING>    
int_to_str:
    mov     byte [minus], 0
    mov     eax, [result_int]   
    mov     ebx, 10         
    mov     ecx, 11       

    mov     edi, result_str   
    add     edi, 10          
    mov     byte [edi], 0      

    test    eax, eax          
    jns     positive_sign     

    mov     byte[minus], 1
    neg     eax            

positive_sign:
    convert_loop_str:
        dec     edi     
        xor     edx, edx 
        div     ebx     

        add     dl, '0' 
        mov     [edi], dl

        test    eax, eax 
        jnz     convert_loop_str

    cmp     byte[minus], 1
    je      add_minus_str
    jmp     return_str
    
add_minus_str:
    dec     edi
    mov     byte [edi], '-'
    
return_str:
    mov     [result_str], edi
    ret
  
    
;   <OPERATION>
operation:
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, info_5
    mov     edx, len_info_5-1
    int     0x80
    
    cmp     dword [count], 1
    jg      repet_oper
    
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, operation_char_2
    mov     edx, 10
    int     0x80
    
    jmp     check

repet_oper:
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, operation_char_2
    mov     edx, 10
    int     0x80
    
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, operation_char_2
    mov     edx, 10
    int     0x80
    
    jmp     check

check:
    cmp     byte [operation_char_2], 'a'
    je      repeat_operation
    
    cmp     byte [operation_char_2], 'c'
    mov     dword [count_two], 2
    je      beginning
    
    cmp     byte [operation_char_2], 'e'
    je      exit
    
    jmp     operation
    
    
exit:
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, endl
    mov     edx, 1
    int     0x80 
    
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, info_6
    mov     edx, len_info_6-1
    int     0x80
    
    mov eax, 1
    int 0x80    
    