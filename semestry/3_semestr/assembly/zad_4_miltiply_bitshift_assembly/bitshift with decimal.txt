section .text
    global _start

section .data
    info_1 db 'Podaj 1 liczbe: ', 0
    len_info_1 equ $-info_1
    
    info_2 db 'Podaj 2 liczbe: ', 0
    len_info_2 equ $-info_2
    
    info_3 db 'Podaj znak +,-,*,/,: ', 0
    len_info_3 equ $-info_3

    star db '*'
    no_v db '-'

section .bss
    one_str resb 32
    one_int resb 32
    
    two_str resb 32
    two_int resb 32
    
    result_int resb 32
    result_str resb 32

section .text
_start:

;   <FIRST NUMBER>
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, info_1
    mov     edx, len_info_1-1
    int     0x80

    mov     eax, 3
    mov     ebx, 0
    mov     ecx, one_str
    mov     edx, 10
    int     0x80
    
    mov     ebx, one_str
    mov     ecx, one_int
    call    str_to_int
    
;   <SECOND NUMBER> 
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, info_2
    mov     edx, len_info_2-1
    int     0x80

    mov     eax, 3
    mov     ebx, 0
    mov     ecx, two_str
    mov     edx, 10
    int     0x80

    mov     ebx, two_str
    mov     ecx, two_int
    call    str_to_int

    mov     edx, dword [one_int]
    mov     ebx, dword [two_int]
    call    multiply
    
print_result:
    call    int_to_str

    ; Prepare parameters for the write syscall
    mov     eax, 4         ; syscall: write
    mov     ebx, 1         ; file descriptor: STDOUT (1)
    mov     ecx, [result_str]; pointer to the string
    mov     edx, 32        ; length of the string
    int     0x80           ; software interrupt
    
    jmp     exit
    
;   <MULTIPLICATION WITH BITSHIFTS>
multiply:
    mov     ecx, 32  ; Set the maximum number of iterations (assuming a 32-bit register)
    xor     eax, eax ; Clear a register for storing the current bit value
    
multiply_loop:
    test    ebx, 1
    jnz     adding

shift:  
    shr     ebx, 1
    shl     edx, 1

    dec     ecx
    cmp     ecx, 0
    jne     multiply_loop
    jmp     print_result

adding:
    add     [result_int], edx    ; Add the shifted value to the result
    jmp     shift


;   <ADDITION>

;   <SUBSTRACTION>

;   <DIVISION>

;   <STRING TO DECIMAL INTEGER>
str_to_int:
    mov     eax, 0
    mov     edx, 0

convert_loop:
    movzx   esi, byte [ebx + edx]
    test    esi, esi
    jz      convert_done

    cmp     esi, '0'
    jl      skip_char
    cmp     esi, '9'
    jg      skip_char

    sub     esi, '0'
    imul    eax, 10
    add     eax, esi

skip_char:
    inc     edx
    jmp     convert_loop

convert_done:
    mov     dword [ecx], eax
    ret
    
;   <DECIMAL INTEGER TO STRING>    
int_to_str:
    mov     eax, [result_int]      ; Load the integer to be converted
    mov     ebx, 10             ; Set divisor to 10
    mov     ecx, 10             ; Set counter for the number of digits in the result

    mov     edi, result_str        ; Set destination address for the string
    add     edi, 10            ; Move the pointer to the end of the buffer
    mov     byte [edi], 0       ; Null-terminate the string

convert_loop_str:
    dec     edi                 ; Move the pointer back one position
    xor     edx, edx            ; Clear any previous remainder
    div     ebx                 ; Divide eax by 10, result in eax, remainder in edx

    add     dl, '0'             ; Convert remainder to ASCII
    mov     [edi], dl           ; Store ASCII character in the string

    test    eax, eax           ; Check if quotient is zero
    jnz     convert_loop_str        ; If not, continue the loop

    mov     [result_str], edi      ; Save the address of the resulting string
    ret    
  
exit:
    mov eax, 1
    int 0x80